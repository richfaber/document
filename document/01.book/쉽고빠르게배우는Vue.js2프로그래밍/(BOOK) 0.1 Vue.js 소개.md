# 0.1 Vue.js 소개

[![9791158390754](https://lh3.googleusercontent.com/-Xh-CwPEt9k8/Wh4ziawNEFI/AAAAAAAATFk/aaG1Y6IaoWU1E2uXh-S8IuABLj6k7NoFwCHMYCw/I/9791158390754.png) 쉽고 빠르게 배우는 Vue.js 2 프로그래밍](http://www.yes24.com/24/goods/44271600?scode=032&OzSrank=1)

코어 라이브러리가 보이는 부분에 초점이 맞춰져 있기 때문에, 외부 라이브러리 혹은 기존의 프로젝트와 통합하기에 매우 적합하게 설계 되었다. 숙련된 프론트엔드 개발자라면 [다른 라이브러리/프레임워크와 비교한 공식 가이드](https://kr.vuejs.org/v2/guide/comparison.html)를 통해 확인해 볼 수 있다.

## 다른 프레임워크와의 비교

### Angular1

Vue의 일부 문법은 Angular와 매우 유사한데, 이것은 Angular에 많은 것들이 제대로 갖춰져 있었고, Vue에 영감을 줬기 때문이다. Angular의 받아들이기 어려울 수도 있는 내용들을 개선하려고 매우 노력했다.

#### 복잡성

Vue는 API 설계 측면에서 Angular1에 비해 간단하고, 학습비용이 적다.

#### 유연성과 모듈성

Angular1은 강제성이 두드러 지지만, Vue의 모듈 방식은 유연한 해결책을 가지고 있다.

#### 데이터 바인딩

Angular1은 유효범위(scope)간 양방향 바인딩을 사용하는 반면 Vue는 컴포넌트 간 단방향 데이터 흐름을 강제한다. (양방향 바인딩은 해당 scope에 값이 미치는 부분이 곳곳에 있어서 수정 하려면 놓치는 부분이 생기기 쉽고, 이건 곧 버그를 의미한다.)

#### 디렉티브 vs 컴포넌트

Vue는 디렉티브와 컴포넌트를 명확히 구분한다. 디렉티브는 DOM 조작을 하기 위함이고, 컴포넌트는 자체 뷰와 로직을 포함한다. (Angular1은 이 개념이 혼란스러운데, 설명 자체를 컴포넌트가 디렉티브의 축소개념이지만 다르지 않다라고 설명하고 있기 때문이라고 생각한다. -_-??)

#### 성능

Vue는 변경감지(dirty checking)을 사용하지 않기 때문에, 빠른 최적화가 된다. Angular1의 성능저하의 원인으로 감시자(watcher)와 다이제스트주기(digest cycle)가 있는데, 예외되는 업데이트사항 들을 따로 관리할 수 있는 난해한 기법을 사용해야 할 때가 종종 있기에 어려움이 있다.

Vue의 모든 변경사항은 명시적으로 종속관계를 만들기 전에는 독립적으로 연결되어 진다.

### Angular 2

#### 규모와 성능

두 프레임워크 모두 매우 빠르고, 실제사용사례가 많지 않아 결론을 내릴 수 없지만, 수치상으로는 Angular2 를 앞서고 있는 것으로 보인다.

규모 측면에서도 Vue의 코어파일이 작기 때문에 Angular2에 비해 용량 또한 적다.

#### 유연성

Angular2 에 비해 덜 강제적이고, 다양한 빌드시스템의 일관된 방법을 공식지원 한다. 개발자들은 컴파일 과정이 다양하길 원하지 않는다. (빌드는 빌드일뿐... 과정을 알고 싶지 않다..)

#### 학습곡선

Vue를 시작하려면 HTML, ES5에 익숙하면 된다. Angular2에서 `Hello world`를 알기 위해 es6, 18개의 npm의존성, 4개의 파일, 3,000개의 단어를 사용해야 하는데, vue는 이에비해 훨씬 간단하며, 앱제작을 위해서는 가이드 전체를 알 필요도 없다.

[nativescript를 통한 vue.js 앱 제작](https://vuejs-kr.github.io/vue/nativescript/2017/08/11/introduce-vue-nativescript-01/)

### React

많은 공통점이 있다.

- 가상 DOM 활용
- 반응적이고 조합 가능한 컴포넌트 방식
- 라우팅 및 전역 상태를 관리하는 컴패니언 라이브러리 제공

#### 성능 분석

##### 렌더링 성능

클라이언트 성능에 영향을 미치는 가장 큰 부분이 DOM렌더링과 조작에 있고, 현재 기술로는 한계가 있기에 선택할 수 있는 몇가지 방법을 Vue.js에서 제공한다.

- 필요한 DOM 조작수 최소화 (가상DOM을 통해서 추상화)
- 가능한 적은 오버헤드(순수 자바스크립트 계산)만 사용으로 비용절감.

렌더링이 필요한 컴포넌트 즉, 상태가 변경되어야 하는 요소가 많을수록 React보다 높은 성능을 보이고, 1개의 컴포넌트를 사용하는 극한의 상황에서는 React보다 느리다.

##### 갱신 성능

Vue의 컴포넌트의 의존성은 자동으로 추적되기 때문에, 해당 의존성 중 하나가 변경될 때만 갱신한다.

##### 개발 시 성능

개발환경에서 vue, react 모두 빠르게 작동한다. 하지만 데이터시각화, 애니메이션 등이 들어가게 되면, vue.js가 더 빠른 프레임으로 렌더링 되는 것을 경험할 수 있다.

이 차이는 React 개발시 각종 경고, 오류 메세지를 출력하는 검사수행 과정이 있기 때문이다.

### Ember

Ember는 완전히 다른 독자적 쳬계를 갖춘 프레임워크이다. 여기에 익숙해지면 생산성 높게 개발이 가능한데, 학습 곡선이 높고 유연성이 떨어진다. (즉 많은 자유도는 금방 적용이 가능하지만 제공되는 기능이 적고, 그 반대의 경우에는 학습비용이 높지만 대부분을 지원해 준다. 심지어는 높은 자유도로 인해 일관되지 않은 코드가 생성되어 같은 프레임워크를 사용함에도 너무도 상이한 코드가 되어버리는 경우가 있는데, jQuery가 그런 자유도가 커서 프로젝트가 망하는 일도 있다. 양날의 검)

### Polymer

구글이 후원하는 또 다른 프로젝트. 아직 보완해야할 사항이 많다고 한다.

### Riot

작고 아름답게 설계된 API, vue는 Riot보다 약간 무겁지만 몇가지 장점이 있다.

- 진정한 조건부 렌더링, Riot는 조건부 렌더링에서 단순히 보여주고 숨기만 것만 한다.
- 강력한 라우터
- 성숙한 도구지원 (Webpack, Browserify)
- 트랜지션 효과 시스템
- 더 나은 성능


